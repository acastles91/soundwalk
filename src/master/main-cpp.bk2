#include <Arduino.h>
#include <WiFi.h>
#include <esp_now.h>

#include <Adafruit_DotStar.h>
#include <math.h>

#include <message.h>          // your shared message types (BREATH/FLICKER/TEST)
#include <motion.h>    // BLDC module we split out
#include <actuator.h>// Actuator module we split out
#include <pins.h>          // shared pin/channel definitions

// --- BEGIN BLDC BRING-UP HELPERS (temporary) ---
static const int8_t HIN_TAB[6][3] = {
  {1,0,0},{1,0,0},{0,1,0},{0,1,0},{0,0,1},{0,0,1}
};
static const int8_t LIN_TAB[6][3] = {
  {0,1,0},{0,0,1},{0,0,1},{1,0,0},{1,0,0},{0,1,0}
};

static inline void setHIN(uint8_t phase, bool on) {
  uint8_t pin = (phase==0)?HIN1:(phase==1)?HIN2:HIN3;
  digitalWrite(pin, on ? HIGH : LOW);
}
static inline void setLIN(uint8_t phase, bool on) {
  uint8_t pin = (phase==0)?LIN1:(phase==1)?LIN2:LIN3;
  digitalWrite(pin, on ? HIGH : LOW);
}

// Hold a known vector to “grab” the rotor (optional but helpful)
static void alignHold(int step = 0, int ms = 600) {
  for (int i=0;i<3;i++) {
    setHIN(i, HIN_TAB[step][i]);
    setLIN(i, LIN_TAB[step][i]);
  }
  delay(ms);
}

// Step through the 6-step table at a given delay (ms) for some cycles
static void commutateSweep(int delay_ms, int cycles) {
  int step = 0;
  for (int c=0; c<cycles; ++c) {
    for (int k=0; k<6; ++k) {
      for (int i=0;i<3;i++) {
        setHIN(i, HIN_TAB[step][i]);
        setLIN(i, LIN_TAB[step][i]);
      }
      delay(delay_ms);
      step = (step+1) % 6;
    }
  }
}

// Simple bring-up sequence you can call once from setup() or via a serial key
static void motorBringUpOnce() {
  // Configure pins for direct digital drive
  pinMode(HIN1, OUTPUT); pinMode(HIN2, OUTPUT); pinMode(HIN3, OUTPUT);
  pinMode(LIN1, OUTPUT); pinMode(LIN2, OUTPUT); pinMode(LIN3, OUTPUT);
  pinMode(ENABLE, OUTPUT); digitalWrite(ENABLE, HIGH);

  // Grab rotor then try a slow sweep (reduce delay if it twitches correctly)
  alignHold(0, 800);
  commutateSweep(/*delay_ms*/ 30, /*cycles*/ 20); // ~3–4 seconds
  // Turn everything off
  for (int i=0;i<3;i++){ setHIN(i,false); setLIN(i,false); }
}
// --- END BLDC BRING-UP HELPERS (temporary) ---

// -------------------- Local DotStar (optional visual) --------------------
#define MASTER_NUM_LEDS   30
Adafruit_DotStar strip(MASTER_NUM_LEDS, MASTER_DATAPIN, MASTER_CLOCKPIN, DOTSTAR_BRG);

// -------------------- ESP-NOW peers --------------------
static const uint8_t PEERS[][6] = {
  {0xC0,0x5D,0x89,0xDC,0xA9,0xDC}, // Slave 0
  {0xC0,0x5D,0x89,0xDC,0x94,0x2C}, // Slave 1
  {0xC0,0x5D,0x89,0xDC,0xA9,0xC0}, // Slave 2
  {0xC0,0x5D,0x89,0xDC,0x99,0x7C}, // Slave 3
  {0xC0,0x5D,0x89,0xDC,0x98,0x08}, // Slave 4
  {0x14,0x2B,0x2F,0xDD,0x69,0xA4}, // Slave 5
  {0xC0,0x5D,0x89,0xDC,0x6E,0xC0}, // Slave 6
  {0xC0,0x5D,0x89,0xDC,0x9A,0x9C}, // Slave 7
  {0xC0,0x5D,0x89,0xDC,0x9B,0xD4}, // Slave 8
  {0xC0,0x5D,0x89,0xDC,0x95,0xD0}, // Slave 9
  {0xC0,0x5D,0x89,0xDC,0xA9,0x28}, // Slave 10
  {0xC0,0x5D,0x89,0xDC,0x9B,0x24}, // Slave 11
  {0xC0,0x5D,0x89,0xDC,0x98,0xB4}, // Slave 12
  {0xC0,0x5D,0x89,0xDC,0xA9,0x2C}, // Slave 13
  {0xC0,0x5D,0x89,0xDC,0x6C,0xCC}, // Slave 14
  {0xC0,0x5D,0x89,0xDC,0x93,0x7C}, // Slave 15
  {0xC0,0x5D,0x89,0xDC,0x7F,0x78}, // Slave 16
  {0xC0,0x5D,0x89,0xDD,0x1E,0x74}, // Slave 17
  {0xC0,0x5D,0x89,0xDC,0x92,0xFC}, // Slave 18
  {0x3C,0x8A,0x1F,0x7D,0xA6,0xE4}, // Slave 19
  {0x38,0x18,0x2B,0x8B,0x85,0xB0}, // Slave 20
  {0x68,0x25,0xDD,0xFD,0x53,0xF4}, // Slave 21
  {0x00,0x4B,0x12,0x33,0x68,0x24}, // Slave 22
  {0x38,0x18,0x2B,0x8B,0x82,0x04}, // Slave 23
  {0x00,0x4B,0x12,0x2E,0xEA,0x14}, // Slave 24
  {0x38,0x18,0x2B,0x8A,0x2A,0xF8}, // Slave 25
  {0x38,0x18,0x2B,0x8B,0xD6,0xBC}, // Slave 26
  {0x68,0x25,0xDD,0xF1,0xB2,0x34}, // Slave 27
  {0x68,0x25,0xDD,0xFD,0x18,0x90}, // Slave 28
};
static const size_t NUM_SLAVES = sizeof(PEERS) / sizeof(PEERS[0]);

// -------------------- ESP-NOW quick helpers --------------------
static uint32_t g_seq = 1;
static uint32_t last_retx_ms = 0;

static BreathMsg  last_breath{};
static bool       have_last_breath = false;

static FlickerMsg last_flicker{};
static bool       have_last_flicker = false;
static uint32_t   last_flicker_retx_ms = 0;

static uint32_t g_test_seq = 1;  // independent sequence counter for test

static void addPeer(const uint8_t mac[6]) {
  esp_now_peer_info_t p{};
  memcpy(p.peer_addr, mac, 6);
  p.channel = 0;
  p.encrypt = false;
  esp_now_add_peer(&p);
}

static void onDataSent(const uint8_t*, esp_now_send_status_t s) {
  Serial.println(s == ESP_NOW_SEND_SUCCESS ? "ESP-NOW send ok" : "ESP-NOW send FAIL");
}

static void setupESPNow() {
  WiFi.mode(WIFI_STA);
  if (esp_now_init() != ESP_OK) {
    Serial.println("ESP-NOW init error");
    return;
  }
  esp_now_register_send_cb(onDataSent);
  if (NUM_SLAVES > 0) addPeer(PEERS[0]);   // only need first; slaves forward down-chain
}

static inline void send_to_first_slave(const void* data, size_t len) {
  if (NUM_SLAVES == 0) return;
  esp_err_t err = esp_now_send(PEERS[0], (const uint8_t*)data, len);
  if (err != ESP_OK) Serial.printf("esp_now_send err=%d\n", err);
}

// -------------------- Commands sent by master --------------------
static void startBreathAll(uint8_t r,uint8_t g,uint8_t b,
                           float bmin,float bmax,
                           uint32_t up_ms,uint32_t down_ms,
                           uint16_t cycles,
                           bool interrupt=false,
                           uint8_t ttl=40,
                           uint32_t start_offset=500)
{
  BreathMsg m{};
  m.mode  = MODE_BREATH;
  m.r = r; m.g = g; m.b = b;
  m.b_min = bmin < 0 ? 0 : (bmin > 1 ? 1 : bmin);
  m.b_max = bmax < 0 ? 0 : (bmax > 1 ? 1 : bmax);
  if (m.b_max < m.b_min) { float t = m.b_min; m.b_min = m.b_max; m.b_max = t; }
  m.up_ms   = up_ms   ? up_ms   : 1;
  m.down_ms = down_ms ? down_ms : 1;
  m.cycles  = cycles;
  m.seq     = g_seq++;
  m.flags   = interrupt ? F_INTERRUPT : 0;
  m.ttl     = ttl;
  m.t0_ms   = millis() + start_offset;

  send_to_first_slave(&m, sizeof(m));
  last_breath = m;
  have_last_breath = true;
}

static void startFlickerAll(uint32_t on_ms,
                            uint32_t off_ms,
                            uint16_t cycles,
                            bool invert=false,
                            bool interrupt=false,
                            uint8_t ttl=40,
                            uint32_t start_offset=300)
{
  FlickerMsg f{};
  f.mode   = MODE_FLICKER;
  f.on_ms  = on_ms  ? on_ms  : 1;
  f.off_ms = off_ms ? off_ms : 1;
  f.cycles = cycles;
  f.invert = invert ? 1 : 0;
  f.seq    = g_seq++;
  f.flags  = interrupt ? F_INTERRUPT : 0;
  f.ttl    = ttl;
  f.t0_ms  = millis() + start_offset;

  send_to_first_slave(&f, sizeof(f));
  last_flicker = f;
  have_last_flicker = true;
}

static void startTestChain(uint16_t step_ms,
                           uint8_t r, uint8_t g, uint8_t b,
                           uint8_t ttl = 40,
                           uint32_t start_offset = 500)
{
  TestMsg t{};
  t.mode    = MODE_TEST;
  t.seq     = g_seq++;
  t.flags   = F_INTERRUPT;     // test preempts
  t.ttl     = ttl;
  t.t0_ms   = millis() + start_offset;
  t.step_ms = step_ms;
  t.r = r; t.g = g; t.b = b;
  send_to_first_slave(&t, sizeof(t));
  Serial.println("TEST chain kicked off.");
}

// -------------------- Local DotStar helpers --------------------
static void fillStrip(uint8_t r,uint8_t g,uint8_t b){
  for (int i=0;i<MASTER_NUM_LEDS;i++) strip.setPixelColor(i, r,g,b);
  strip.show();
}

// ---- Simple actuator console ----
static String g_line;

static void printHelp(){
  Serial.println(F(
    "\nActuator console:\n"
    "  f N      -> forward with duty N (0..255)\n"
    "  r N      -> reverse with duty N (0..255)\n"
    "  c        -> coast (both low)\n"
    "  b [N]    -> brake, optional duty N (default 255)\n"
    "  burst P T-> burst with signed power P (-255..255) for T ms\n"
    "  auto on  -> enable auto SM\n"
    "  auto off -> disable auto\n"
    "  auto set f a b -> set FORWARD min/max (ms)\n"
    "  auto set r a b -> set REVERSE min/max (ms)\n"
    "  auto set k a b -> set BRAKE   min/max (ms)\n"
    "  auto set s a b -> set COAST   min/max (ms)\n"
    "  auto duty N    -> set runDuty for AUTO\n"
    "  brake duty N   -> set brakeDuty for AUTO\n"
    "  status   -> print status\n"
    "  ?        -> this help\n"
  ));
}

static void splitTokens(const String& s, String out[], int& n, int maxN){
  n = 0; int i=0;
  while (i < (int)s.length()){
    while (i<(int)s.length() && isspace(s[i])) i++;
    if (i >= (int)s.length()) break;
    int j=i;
    while (j<(int)s.length() && !isspace(s[j])) j++;
    if (n < maxN) out[n++] = s.substring(i,j);
    i = j;
  }
}

static long toLong(const String& s, long def=0){ char* e=nullptr; long v=strtol(s.c_str(), &e, 10); return (e && *e==0) ? v : def; }

static void handleCommand(const String& line){
  String t[8]; int n=0; splitTokens(line, t, n, 8);
  if (n==0) return;

  if (t[0] == "?" || t[0]=="help"){ printHelp(); return; }

  if (t[0] == "f" && n>=2){
    int d = constrain((int)toLong(t[1], 120), 0, 255);
    actuator::drive(d);
    Serial.printf("MANUAL forward %d\n", d);
    return;
  }
  if (t[0] == "r" && n>=2){
    int d = constrain((int)toLong(t[1], 120), 0, 255);
    actuator::drive(-d);
    Serial.printf("MANUAL reverse %d\n", d);
    return;
  }
  if (t[0] == "c"){
    actuator::coast();
    Serial.println("COAST");
    return;
  }
  if (t[0] == "b"){
    int d = (n>=2) ? constrain((int)toLong(t[1],255),0,255) : 255;
    actuator::brake(d);
    Serial.printf("BRAKE duty=%d\n", d);
    return;
  }
  if (t[0] == "burst" && n>=3){
    int p = constrain((int)toLong(t[1], 200), -255, 255);
    int ms= max(0,(int)toLong(t[2], 100));
    actuator::burst(p, (uint16_t)ms);
    Serial.printf("BURST power=%d ms=%d\n", p, ms);
    return;
  }
  if (t[0] == "auto" && n>=2){
    if (t[1] == "on"){
      actuator::enableAuto(true);
      Serial.println("AUTO on");
      return;
    } else if (t[1] == "off"){
      actuator::enableAuto(false);
      Serial.println("AUTO off");
      return;
    } else if (t[1] == "duty" && n>=3){
      auto cfg = actuator::getAutoConfig();
      cfg.runDuty = constrain((int)toLong(t[2], cfg.runDuty), 0, 255);
      actuator::setAutoConfig(cfg);
      Serial.printf("AUTO runDuty=%d\n", cfg.runDuty);
      return;
    } else if (t[1] == "set" && n>=5){
      auto cfg = actuator::getAutoConfig();
      uint16_t a = (uint16_t)max(0L, toLong(t[3],0));
      uint16_t b = (uint16_t)max(0L, toLong(t[4],0));
      if (t[2] == "f"){ cfg.fwdMinMs=a; cfg.fwdMaxMs=b; }
      else if (t[2] == "r"){ cfg.revMinMs=a; cfg.revMaxMs=b; }
      else if (t[2] == "k"){ cfg.brakeMinMs=a; cfg.brakeMaxMs=b; }
      else if (t[2] == "s"){ cfg.coastMinMs=a; cfg.coastMaxMs=b; }
      actuator::setAutoConfig(cfg);
      Serial.printf("AUTO set %s=(%u..%u)ms\n", t[2].c_str(), a,b);
      return;
    }
  }
  if (t[0] == "brake" && n>=3 && t[1] == "duty"){
    auto cfg = actuator::getAutoConfig();
    cfg.brakeDuty = constrain((int)toLong(t[2], cfg.brakeDuty), 0, 255);
    actuator::setAutoConfig(cfg);
    Serial.printf("AUTO brakeDuty=%d\n", cfg.brakeDuty);
    return;
  }
  if (t[0] == "status"){
    actuator::debugPrint(Serial);
    return;
  }
  Serial.println("Unknown command. Type '?' for help.");
}

static void handleSerial(){
  while (Serial.available()){
    char c = (char)Serial.read();
    if (c=='\r') continue;
    if (c=='\n'){ handleCommand(g_line); g_line = ""; }
    else        { g_line += c; }
  }
}

// -------------------- Arduino setup/loop --------------------
void setup() {
  Serial.begin(115200);

  // Local status LED (optional)
  pinMode(LED_BUILTIN, OUTPUT);

  // Local DotStar (optional)
  strip.begin();
  strip.show(); // all off

  // ESP-NOW
  setupESPNow();
  Serial.print("Master MAC: "); Serial.println(WiFi.macAddress());

  // --- MOTOR (BLDC) ---
  motion::Config mcfg;
  mcfg.min_delay_us   = 12 * 1000;
  mcfg.max_delay_us   = 55 * 1000;
  mcfg.ramp_k         = 0.65f;
  mcfg.base_pwm_duty  = PWM_DEFAULT_DUTY;
  mcfg.use_zero_cross = false; // keep false until ZC is wired in module
  motion::setup(mcfg);
  motion::startOpenLoop();

  // --- ACTUATOR (DRV8833) ---
  actuator::setup(AIN1, AIN2, AIN1_CH, AIN2_CH, /*freq*/40, /*res*/8);
  actuator::AutoConfig acfg;       // defaults mimic your previous values
  actuator::setAutoConfig(acfg);
  actuator::enableAuto(true);

  // Kick off a default breath so slaves show life
  startBreathAll(/*r*/0,/*g*/0,/*b*/255,
                 /*bmin*/0.05f,/*bmax*/0.6f,
                 /*up*/1200,/*down*/1400,
                 /*cycles*/0, /*interrupt*/true);

  // Local strip to blue
  fillStrip(0,0,40);
}

void loop() {
  const uint32_t now = millis();

  // Keep modules alive (non-blocking)
  motion::tick();
  actuator::tick();

  // Periodically re-broadcast last BREATH so late joiners sync
  if (have_last_breath) {
    if (now - last_retx_ms > 2000) {
      last_retx_ms = now;
      BreathMsg reb = last_breath;           // copy
      reb.t0_ms = now + 200;                 // near-future start
      // same seq -> already-synced nodes ignore
      send_to_first_slave(&reb, sizeof(reb));
    }
  }
  // Periodically re-broadcast last FLICKER too
  if (have_last_flicker) {
    if (now - last_flicker_retx_ms > 1000) {
      last_flicker_retx_ms = now;
      FlickerMsg f = last_flicker;
      f.t0_ms = now + 80;
      send_to_first_slave(&f, sizeof(f));
    }
  }

  // ---- simple serial UI ----
  if (Serial.available()) {
    char c = (char)Serial.read();
    switch (c) {
      case 'b': // blue breath
        startBreathAll(0,0,255, 0.05f,0.7f, 1000,1200, 0, true);
        Serial.println("BREATH: blue");
        break;
      case 'f': // fast flicker
        startFlickerAll(20,20, 40, false, true);
        Serial.println("FLICKER: 60/60 continuous");
        break;
      case 'c': // clear flicker (one short pulse, then off)
        startFlickerAll(1,0,1, false, true);
        Serial.println("FLICKER: cleared");
        break;
      case 't': // start LED test chain (500 ms per LED, red)
        startTestChain(/*step_ms*/50, /*r*/255,/*g*/0,/*b*/0, /*ttl*/60);
        Serial.println("TEST: chain started");
        break;
      case 'r': // red breath
        startBreathAll(255,0,0, 0.05f,0.6f, 900,1100, 0, true);
        Serial.println("BREATH: red");
        break;
      case 'g': // green breath
        startBreathAll(0,255,0, 0.05f,0.6f, 900,1100, 0, true);
        Serial.println("BREATH: green");
        break;
      case 'm':
        Serial.println("Manual 6-step bring-up…");
        motorBringUpOnce();
        break;
      
      default:
        break;
    }
  }

  // Small local status effect (optional)
  static uint32_t led_ms = 0;
  if (now - led_ms > 500) {
    led_ms = now;
    digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));
  }
}
